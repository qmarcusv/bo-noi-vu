import { promises as fs } from "node:fs";
import path from "node:path";

const HOME_DIR = path.resolve(process.cwd(), "public", "assets", "home");
const OUTPUT_FILE = path.resolve(process.cwd(), "src", "data", "generated-home-videos.ts");

const VIDEO_EXTENSIONS = new Set([".mp4", ".webm", ".ogg", ".mov", ".MP4", ".WEBM", ".OGG", ".MOV"]);

async function walkDir(dir) {
	const entries = await fs.readdir(dir, { withFileTypes: true });
	const files = await Promise.all(
		entries.map(async (entry) => {
			const fullPath = path.join(dir, entry.name);
			if (entry.isDirectory()) {
				return walkDir(fullPath);
			}
			return fullPath;
		})
	);
	return files.flat();
}

function toPublicUrl(absoluteFilePath) {
	const rel = path.relative(path.resolve(process.cwd(), "public"), absoluteFilePath);
	return "/" + rel.split(path.sep).join("/");
}

async function generate() {
	try {
		await fs.mkdir(path.dirname(OUTPUT_FILE), { recursive: true });

		let allFiles = [];
		try {
			allFiles = await walkDir(HOME_DIR);
		} catch {
			// keep empty if dir not found
		}

		const videoFiles = allFiles.filter((f) => VIDEO_EXTENSIONS.has(path.extname(f)));

		const items = videoFiles
			.sort((a, b) => a.localeCompare(b))
			.map((absPath, index) => {
				const url = toPublicUrl(absPath);
				const base = path.basename(absPath, path.extname(absPath));
				const id = `home-video-${index + 1}-${base}`;
				return { id, src: url };
			});

		const fileContent = `// AUTO-GENERATED FILE. DO NOT EDIT.
// Generated by scripts/generate-home.mjs
export const generatedHomeVideos: ReadonlyArray<{ id: string; src: string }> = ${JSON.stringify(items, null, 2)};
`;

		await fs.writeFile(OUTPUT_FILE, fileContent, "utf8");
		console.log(`[home] Wrote ${items.length} videos to ${path.relative(process.cwd(), OUTPUT_FILE)}`);
	} catch (err) {
		console.error("[home] Failed to generate videos:", err);
		process.exitCode = 1;
	}
}

generate();
